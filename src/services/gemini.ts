import { GoogleGenAI } from "@google/genai";
import { OutputFormat, PredictionResponse } from '@/types';

export interface GenerateImageGeminiOptions {
  prompt: string;
  apiKey: string;
  images?: string[]; // base64 data URIs for image editing
  aspectRatio?: string;
  outputFormat?: OutputFormat;
}

/**
 * Generate images using Gemini's native image generation
 * Supports both text-to-image and image editing (text + image to image)
 */
export async function generateImageGemini(
  options: GenerateImageGeminiOptions
): Promise<PredictionResponse> {
  const {
    prompt,
    apiKey,
    images = [],
    aspectRatio = "1:1",
    outputFormat = 'png',
  } = options;

  if (!apiKey) {
    throw new Error('Gemini API key is required');
  }

  if (!prompt.trim()) {
    throw new Error('Prompt is required');
  }

  try {
    console.log('Gemini API key tryyy:', apiKey);
    const ai = new GoogleGenAI({
      apiKey,
    });

    // Build the contents array for the API call
    const contents: any[] = [{ text: prompt }];

    // Add images if provided (for image editing)
    if (images.length > 0) {
      for (const imageDataUri of images) {
        // Extract base64 data and mime type from data URI
        const matches = imageDataUri.match(/^data:([^;]+);base64,(.+)$/);
        if (matches) {
          const mimeType = matches[1];
          const base64Data = matches[2];
          
          contents.push({
            inlineData: {
              mimeType,
              data: base64Data,
            },
          });
        } else {
          throw new Error('Invalid image data URI format');
        }
      }
    }

    // Build config with aspectRatio
    const config: any = {
      imageConfig: {
        aspectRatio,
      },
    };

    // Make the API call
    const response = await ai.models.generateContent({
      model: "gemini-2.5-flash-image",
      contents,
      config,
    });

    // Process the response
    const outputs: string[] = [];
    
    if (response.candidates && response.candidates.length > 0) {
      const candidate = response.candidates[0];
      if (candidate.content && candidate.content.parts) {
        for (const part of candidate.content.parts) {
          if (part.text) {
            console.log('Gemini response text:', part.text);
          } else if (part.inlineData) {
            // Convert the response to a data URI
            const base64Data = part.inlineData.data;
            const mimeType = part.inlineData.mimeType || `image/${outputFormat}`;
            const dataUri = `data:${mimeType};base64,${base64Data}`;
            outputs.push(dataUri);
          }
        }
      }
    }

    if (outputs.length === 0) {
      throw new Error('No image generated by Gemini API');
    }

    // Return in the same format as wavespeed for consistency
    return {
      created_at: new Date().toISOString(),
      id: `gemini-${Date.now()}`,
      model: 'gemini-2.5-flash-image',
      outputs,
      status: 'succeeded',
    };
  } catch (error) {
    if (error instanceof Error) {
      const errorMessage = error.message.toLowerCase();
      
      // Check for common error types and provide helpful messages
      if (errorMessage.includes('quota') || errorMessage.includes('rate limit')) {
        throw new Error(`Gemini API quota exceeded. Please check your API key and usage limits at https://aistudio.google.com/app/apikey`);
      } else if (errorMessage.includes('api key') || errorMessage.includes('invalid') || errorMessage.includes('unauthorized')) {
        throw new Error(`Invalid Gemini API key. Please verify your API key at https://aistudio.google.com/app/apikey`);
      } else if (errorMessage.includes('permission')) {
        throw new Error(`Gemini API permission denied. Make sure your API key has access to image generation.`);
      }
      
      throw new Error(`Gemini API request failed: ${error.message}`);
    }
    throw error;
  }
}

/**
 * Map common size strings to Gemini aspect ratios
 */
export function sizeToAspectRatio(size: string): string {
  const sizeMap: Record<string, string> = {
    '512*512': '1:1',
    '1024*1024': '1:1',
    '1536*1536': '1:1',
    '832*1248': '2:3',
    '1248*832': '3:2',
    '864*1184': '3:4',
    '1184*864': '4:3',
    '896*1152': '4:5',
    '1152*896': '5:4',
    '768*1344': '9:16',
    '1344*768': '16:9',
    '1536*672': '21:9',
  };

  // Check if the size is a known preset
  if (sizeMap[size]) {
    return sizeMap[size];
  }

  // Try to parse custom size format (e.g., "1024*768")
  const match = size.match(/^(\d+)\*(\d+)$/);
  if (match) {
    const width = parseInt(match[1]);
    const height = parseInt(match[2]);
    
    // Calculate aspect ratio
    const gcd = (a: number, b: number): number => b === 0 ? a : gcd(b, a % b);
    const divisor = gcd(width, height);
    return `${width / divisor}:${height / divisor}`;
  }

  // Default to 1:1
  return '1:1';
}

